import { hideBin } from "yargs/helpers";
import yargs, { Argv } from "yargs";
import { AgentConfig, loadFromConfigFile } from "./config";
import { CommandModeType } from "../types/types";

/****  Command options ****/

// Putting this in a namespace means that the config parsing code can loop
// through it and figure out which options we want
export namespace Options {
  export const eventFile: [string, yargs.Options]  = ['f', {
    alias: 'event-file',
    demandOption: false,
    describe: 'Filename to log event stream',
    type: 'string'
  }];

  export const shadowStack: [string, yargs.Options] = ['shadow-stack', {
    demandOption: false,
    describe: "Use a shadow stack or not, can disable with --no-shadow-stack",
    type: 'boolean',
    default: true
  }];

  export const eventThreshold: [string, yargs.Options]  = ['event-threshold', {
    demandOption: false,
    describe: "Set the minimum (inclusive) sensitivity for event reporting",
    type: 'number',
    default: 1
  }];

  export const proxySpecsDir: [string, yargs.Options]  = ['proxy-specs-dir', {
    demandOption: false,
    describe: 'Directory for proxy specifications',
    type: 'string'
  }];

  export const traceUnknownBuiltins: [string, yargs.Options] = ['trace-unknown-builtins', {
    demandOption: false,
    describe: "Trace unknown built-in modules",
    type: 'boolean',
    default: false
  }];

  export const privsFile: [string, yargs.Options] = ["p", {
    alias: 'privs-file',
    description: "Save privileges to file",
    type: 'string',
    demandOption: false
  }];

  export const logDuplicateEvents: [string, yargs.Options] = ['log-duplicate-events', {
    demandOption: false,
    describe: "Emit log messages for events we've already seen",
    type: 'boolean',
    default: false
  }];

  export const blockSensitivity: [string, yargs.Options] = ['block-sensitivity', {
    description: "Minimum sensitivity at which violations will be blocked",
    type: 'number',
    default: 1
  }]

  export const traceGranularity: [string, yargs.Options] = ['trace-granularity', {
    description: "Granularity at which to run the trace",
    type: 'string',
    default: 'library',
    choices: ['library', 'file']
  }]

  export const dashboardPort: [string, yargs.Options] = ['dashboard-port', {
    description: "Connec to the web UI",
    type: 'number',
    demandOption: false,
    default: null
  }]
}
// set up the commands and arguments
// right now we have a learn and a protect command
// they share lots of options
export const argParser = yargs
  .command('learn', 'Learn privileges: provide program and args after a --', (yargs) => { yargs
      .option(...Options.eventFile)
      .option(...Options.shadowStack)
      .option(...Options.eventThreshold)
      .option(...Options.proxySpecsDir)
      .option(...Options.logDuplicateEvents)
      .option(...Options.privsFile)
      .option(...Options.traceGranularity)
      // options specific to learn
      .option(...Options.traceUnknownBuiltins)
      .option(...Options.dashboardPort)
  })
  .command('enforce', 'Enforce privileges', (yargs) => { yargs
      .option(...Options.eventFile)
      .option(...Options.shadowStack)
      .option(...Options.eventThreshold)
      .option(...Options.proxySpecsDir)
      .option(...Options.logDuplicateEvents)
      .option(...Options.privsFile)
      .option(...Options.traceGranularity)
      // options specific to enforce
      .option(...Options.blockSensitivity)
    })
  .strict()
  .help()
  .usage(`$0 [command]

  If no command is supplied, configuration will be read from the
  file pointed to by the environment variable REQSEC_AGENT_CONFIG

  See README.md for the configuration file format`)

function CLIError(argParser: Argv, message: string) {
  argParser.showHelp();
  console.log("\nError: " + message);
  process.exit(1);
}

export function parseCLI()  {
  const args = argParser.parseSync(hideBin(process.argv)) as Partial<AgentConfig>
                                                             & {_: string[]}
  // Most of the arguments are generated by yargs, but we have
  // to add some manually

  // This will either be learn/enforce, or the target program
  args.mode = args._[0] as CommandModeType

  // If mode isn't set, read from config file instead
  if (!["enforce", "learn"].includes(args.mode)) {
    const config = loadFromConfigFile(args._)
    return {config: config, targetCmd: args._}
  }

  if(args.mode == "enforce" && !args.privsFile) {
    throw Error("Need a privs file to enforce from")
  }

  // args._ will be [<mode>, target, ...targetArgs], so
  // we leave off mode and store the rest
  if (!args._ || args._.length < 2) {
    CLIError(argParser, "No program provided. Please provide a program to execute.");
  }
  const targetCmd = args._.slice(1).map(String);

  return {config: args as AgentConfig, targetCmd: targetCmd}
}
